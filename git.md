# Git-Github

## Introduccion

3. Version control software - Control de versiones
   
   1. Registra los cambios que realizados en un archivo a lo largo del tiempo en una base de datos interna
   2. Es posible hacer un seguimiento de cada cambio que se hace, cuando se hace, quien lo hace
   3. Recuperar versiones viejas
   
4. Git es un control de versiones distribuido

   1. Los clientes no descargan unicamente la copia de los archivos, sino que se descarga todo el repositorio
   2. Cada clon es una copia completa de todos los datos (diferentes versiones, database con la bitacora de cambios...)

   


### Conceptos generales de git

1. Git maneja tus datos como una secuencia de copias instantaneas
2. Cada vez que se guarda el estado de un proyecto, se guarda una copia de todo el estado de los archivos
3. Si hay archivos que no se han modificado se guarda un enlace al archivo anterior que ya esta almacenado
4. Se parece a un sistema de archivos en miniatura
5. Casi todas las operaciones se realizan de forma local
6. Git tiene integridad por sha1

### Los 3 estados

1. Git tiene tres estados en los que se pueden encontrar los archivos:

   1. **Confirmado (committed)**: Los datos estan almacenados de forma segura en tu base de datos local
   2. **Modificado (modified)**: Se ha modificado el archivo pero aún no se ha almacenado/confirmado en la base de datos
   3. **Preparado (staged)**: Se ha marcado un archivo en su versión actual para que se confirme.

2. Por lo tanto un proyecto en Git tiene tres secciones:

   1. **Git directory (repository)**: Donde se almacenan los metadatos del proyecto y la base de datos de objetos. Esta es la parte que se copia cuando se clona un repositorio.

   2. **Directorio de trabajo (working directory)**: Es una copia de una versión del proyecto. Estos archivos se obtienen de  la base de datos comprimida en el directorio de Git y se colocan en el disco para que se puedan usar o modificar.

   3. **Directorio de preparación (staging area)**: Es un archivo, generalmente contenido en tu directorio Git, que almacena información acerca de los objetos que se van a almacenar en la próxima acción de confirmación. Se denomina index o area de preparación.

#### Flujo de trabajo

Un flujo de trabajo típico es:

1. Se modifican una serie de archivos en el directorio de trabajo
2. Se "marcan" los archivos, se preparan, por lo tanto estan en la zona de preparación
3. Se confirman los cambios, por lo tanto se "recogen" los archivos tal y como estan en la zona de preparación y se almacena esa copia de forma permanente en tu directorio Git.

### Configurando Git

Git trae una herramienta llamada `git config`, que te permite obtener y establecer variables de configuración que controlan el aspecto y funcionamiento de Git. Estas variables pueden almacenarse en tres sitios distintos:

1. Archivo `/etc/gitconfig`: Contiene valores para todos los usuarios del sistema y todos sus repositorios. Si pasas la opción `--system` a `git config`, lee y escribe específicamente en este archivo.
2. Archivo `~/.gitconfig` o `~/.config/git/config`: Este archivo es específico de tu usuario. Puedes hacer que Git lea y escriba específicamente en este archivo pasando la opción `--global`.
3. Archivo `config` en el directorio de Git (es decir, `.git/config`) del repositorio que estés utilizando actualmente: Este archivo es específico del repositorio actual.

Cada nivel sobrescribe los valores del nivel anterior, por lo que los valores de `.git/config` tienen preferencia sobre los de `/etc/gitconfig`.

Lo primero que deberás hacer cuando instales Git es establecer tu nombre de usuario y dirección de correo electrónico. Esto es importante porque los "commits" de Git usan esta información, y es introducida de manera inmutable en los commits que envías:

```console
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```

De nuevo, sólo necesitas hacer esto una vez si especificas la opción `--global`, ya que Git siempre usará esta información para todo lo que hagas en ese sistema. Si quieres sobrescribir esta información con otro nombre o dirección de correo para proyectos específicos, puedes ejecutar el comando sin la opción `--global` cuando estés en ese proyecto.

## Fundamentos

### Creacion

1. Creación de un subdirectorio para crear un proyecto:

   ```
   git init
   ```

2. Obtener una copia de un repositorio existente:

   ```
   git clone [url] [repository name]
   ```

3. En este caso se esta usando http, pero tambien se puede hacer mediante ssh

### Guardando cambios

1. **Archivos rastreados:** Todos los archivos que estaban en la ultima instancia del proyecto (tracked files)

2. **Archivos no rastreados:** Todos los demas (que estan en tu area de trabajo pero que no estaban en la ultima instancia y no estan marcados)

3.  Cuando se clona un repositorio todos los archivos estan rastreados

4. Para revisar el status de un archivo:

   ```
   git status
   ```

5. Ejemplo:

   ```bash
   ignasi@debian:~$ cd test/Awae/
   ignasi@debian:~/test/Awae$ git status
   En la rama main
   Tu rama está actualizada con 'origin/main'.
   
   nada para hacer commit, el árbol de trabajo está limpio
   ignasi@debian:~/test/Awae$ nano Readme_untracked.md
   ignasi@debian:~/test/Awae$ git status
   En la rama main
   Tu rama está actualizada con 'origin/main'.
   
   Archivos sin seguimiento:
     (usa "git add <archivo>..." para incluirlo a lo que se será confirmado)
   
   	Readme_untracked.md
   
   no hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa "git add" para hacerles seguimiento)
   ignasi@debian:~/test/Awae$ 
   
   ```

   El fichero Readme_untracked esta "sin seguimiento/sin rastrear" pq Git sabe que este fichero es nuevo, que no estaba en el ultimo commit realizado.

6. Iniciando "seguimiento":

   ```
   ignasi@debian:~/test/Awae$ git status 
   En la rama main
   Tu rama está actualizada con 'origin/main'.
   
   Cambios a ser confirmados:
     (usa "git reset HEAD <archivo>..." para sacar del área de stage)
   
   	nuevo archivo:  Readme_untracked.md
   ```

7. Ahora este fichero ya esta en el area de "preparacion", esta en seguimiento y listo para ser commiteado

8. Tambien pueden haber archivos en el area de preparacion que no sean "nuevos" sino que ya estaban pero se han modificado:

   ```
   ignasi@debian:~/test/Awae$ git status 
   En la rama main
   Tu rama está actualizada con 'origin/main'.
   
   Cambios a ser confirmados:
     (usa "git reset HEAD <archivo>..." para sacar del área de stage)
   
   	nuevo archivo:  Readme_untracked.md
   
   Cambios no rastreados para el commit:
     (usa "git add <archivo>..." para actualizar lo que será confirmado)
     (usa "git checkout -- <archivo>..." para descartar los cambios en el directorio de trabajo)
   
   	modificado:     README.md
   
   ignasi@debian:~/test/Awae$ git add README.md 
   ignasi@debian:~/test/Awae$ git status
   En la rama main
   Tu rama está actualizada con 'origin/main'.
   
   Cambios a ser confirmados:
     (usa "git reset HEAD <archivo>..." para sacar del área de stage)
   
   	modificado:     README.md
   	nuevo archivo:  Readme_untracked.md
   
   ignasi@debian:~/test/Awae$ 
   
   ```

9. Para ver que cambios se han realizado:

   ```
   ignasi@debian:~/test/Awae$ git diff
   ignasi@debian:~/test/Awae$ git diff --staged
   diff --git a/README.md b/README.md
   index 1e851ba..de82978 100644
   --- a/README.md
   +++ b/README.md
   @@ -22,3 +22,5 @@
    ## XSS
    
    1.  XSS + SQL + RCE: https://sarthaksaini.com/2019/awae/xss-rce.html 
   +
   +(change)
   diff --git a/Readme_untracked.md b/Readme_untracked.md
   new file mode 100644
   index 0000000..9daeafb
   --- /dev/null
   +++ b/Readme_untracked.md
   @@ -0,0 +1 @@
   +test
   
   ```

10. Es importante resaltar que al llamar a `git diff` sin parámetros no verás los cambios desde tu última confirmación - solo verás los cambios que aun no están preparados. Esto puede ser confuso porque si preparas todos tus cambios, `git diff` no te devolverá ninguna salida.

### Confirmando cambios

1. Para confirmar los cambios que hay en la zona de preparacion:

   ```
   git commit
   git commit -m "text"
   ```

2. Para preparar automáticamente todos los archivos rastreados y confirmarmlos:

   ```
   git commit -a -m "text"
   ```

### Eliminar archivos

1. Primero hay que eliminarlos de tus archivos rastreados mediante:

   ```
   git rm
   ```

2. Luego habra que volver a confirmar

3. Para cambiar el nombre de un archivo:

   ```
   git mv file_from file_to
   ```

### Historial

```
git log
git log -p
git loh -p -2
```

## Ramificaciones de Git

### Que es una rama

1. En cada commit Git almacena una instancia de tu trabajo preparado
2. Además cada copia contiene metadatos, apuntadores, mensajes etc
3. Ejemplo:
   1. Directorio con 3 archivos
   2. Se preparan los 3 archivos (staged)
   3. Se realiza un commit
   4. Git hace una suma de control (sha-1), almacena una copia de cada archivo en el repositorio (cada copia recibe el nombre de "blob") y guarda cada suma de control en el area de preparacion
   5. Cuando se hace un commit que tiene el repositorio de Git:
      1. Un blob para cada archivo commiteado
      2. Un arbol con una lista de contenidos del directorio
      3. Metadatos (confirmacion del commit, sumas sha1 etc )
   6. Cada vez que se hacen cambios y commits, la ultima commit realizada guardara un enlace a su confirmacion precedente
   7. Asi que una rama no deja de ser un apuntador movil apuntando a una de esas confirmaciones y por ende, a sus precedentes (historial)
   8. Una rama no deja de ser una coleccion/grupo de commits (historial)

### Creación de una nueva rama

1. Si creas una nueva rama, que estas haciendo? 

2. Simplemente, estas creando un nuevo apuntador que "bifurcara" a partir del commit donde estas.

3. Para crear la rama, que no saltar a ella, el comando es:

   ```
   git branch [name]
   ```

4. Existe un apuntador especial que se llama HEAD que permite saber en que rama estas

   ```
   git log --oneline --decorate
   ignasi@debian:~/test/Awae$ git log --oneline --decorate
   b25c16e (HEAD -> main, testing) Confirmacion realizada
   3d792df (origin/main, origin/HEAD) Update code_review.md
   
   ```

5. Para saltar de rama:

   ```
   git checkout [name]
   ```

6. Head ahora apuntara a la nueva rama, y Git revertira los archivos de tu directorio de trabajado al ultimo estado commit de la rama master, para que asi se pueda empezar desde 0 ( partiendo de ese ultimo commit en master) en la nueva rama

   ```
   git checkout testing
   Cambiado a rama 'testing'
   ignasi@debian:~/test/Awae$ ls
   exercices  python  README.md  Readme_untracked.md  theory
   ignasi@debian:~/test/Awae$ touch Readme_testing.md
   ignasi@debian:~/test/Awae$ git add Readme_testing.md 
   ignasi@debian:~/test/Awae$ sudo git commit -m "Adding Reame testing"
   [sudo] password for ignasi: 
   Sorry, try again.
   [sudo] password for ignasi: 
   Sorry, try again.
   [sudo] password for ignasi: 
   [testing b9c8ac6] Adding Reame testing
    1 file changed, 0 insertions(+), 0 deletions(-)
    create mode 100644 Readme_testing.md
   ignasi@debian:~/test/Awae$ git status
   En la rama testing
   nada para hacer commit, el árbol de trabajo está limpio
   ignasi@debian:~/test/Awae$ 
   ```

7. Si ahora volvieramos a la rama master, veriamos lo siguiente

   ```
   ignasi@debian:~/test/Awae$ git checkout main
   Cambiado a rama 'main'
   Tu rama está adelantada a 'origin/main' por 1 commit.
     (usa "git push" para publicar tus commits locales)
     ignasi@debian:~/test/Awae$ ls
   exercices  python  README.md  Readme_untracked.md  theory
   ignasi@debian:~/test/Awae$ git checkout testing
   Cambiado a rama 'testing'
   ignasi@debian:~/test/Awae$ ls
   exercices  python  README.md  Readme_testing.md  Readme_untracked.md  theory
   ignasi@debian:~/test/Awae$ 
   
   ignasi@debian:~/test/Awae$  git log --oneline --decorate --graph --all
   * b9c8ac6 (HEAD -> testing) Adding Reame testing
   * b25c16e (main) Confirmacion realizada
   * 3d792df (origin/main, origin/HEAD) Update code_review.md
   
   ```

### Ramificaciones en Git

1. Para crear una rama y saltar a ella directamente:

   ```
   ignasi@debian:~/test/Awae$ git checkout -b develop
   Cambiado a nueva rama 'develop'
   
   ignasi@debian:~/test/Awae$ ls
   exercices  python  README.md  Readme_untracked.md  theory
   ignasi@debian:~/test/Awae$ touch Readme_develop
   ignasi@debian:~/test/Awae$ git add Readme_develop 
   ignasi@debian:~/test/Awae$ sudo git commit -m "Adding develop"
   [develop dfc1aa2] Adding develop
    1 file changed, 0 insertions(+), 0 deletions(-)
    create mode 100644 Readme_develop
   
   ```

2. Es **importante** que para saltar entre ramas el entorno de trabajo este limpio, sino, podemos perder información entre saltos

3. Creamos una rama hotfix, pero que bifurca de Develop:

   ```bash
   ignasi@debian:~/test/Awae$ git checkout -b hotfix
   Cambiado a nueva rama 'hotfix'
   ignasi@debian:~/test/Awae$ ls
   exercices  python  Readme_develop  README.md  Readme_untracked.md  theory
   ignasi@debian:~/test/Awae$ touch Readme_hotfix
   ignasi@debian:~/test/Awae$ nano Readme_develop 
   ignasi@debian:~/test/Awae$ git add .
   ignasi@debian:~/test/Awae$ git status
   En la rama hotfix
   Cambios a ser confirmados:
     (usa "git reset HEAD <archivo>..." para sacar del área de stage)
   
   	modificado:     Readme_develop
   	nuevo archivo:  Readme_hotfix
   ignasi@debian:~/test/Awae$ sudo git commit -m "adding hotfix"
   [hotfix f15f124] adding hotfix
    2 files changed, 1 insertion(+)
    create mode 100644 Readme_hotfix
   
   ```

4. Ahora queremos incorporar los cambios de hotfix a develop, hacer un merge:

   ```
   ignasi@debian:~/test/Awae$ git checkout develop
   Cambiado a rama 'develop'
   ignasi@debian:~/test/Awae$ git merge hotfix
   Actualizando dfc1aa2..f15f124
   Fast-forward
    Readme_develop | 1 +
    Readme_hotfix  | 0
    2 files changed, 1 insertion(+)
    create mode 100644 Readme_hotfix
   ignasi@debian:~/test/Awae$ 
   ```

5. Y ahora eliminamos la rama hotfix:

   ``` 
   ignasi@debian:~/test/Awae$ git branch -d hotfix
   Eliminada la rama hotfix (era f15f124)..
   
   ```

6. Ramas actuales:

   ```bash
   ignasi@debian:~/test/Awae$ git branch
   * develop
     main
     testing
   ```

7. Actualización:

   ```
   ignasi@debian:~/test/Awae$ git checkout main
   Cambiado a rama 'main'
   Tu rama está adelantada a 'origin/main' por 1 commit.
     (usa "git push" para publicar tus commits locales)
   ignasi@debian:~/test/Awae$ git push
   
   Enumerando objetos: 6, listo.
   Contando objetos: 100% (6/6), listo.
   Compresión delta usando hasta 8 hilos
   Comprimiendo objetos: 100% (3/3), listo.
   Escribiendo objetos: 100% (4/4), 437 bytes | 437.00 KiB/s, listo.
   Total 4 (delta 1), reusado 0 (delta 0)
   remote: Resolving deltas: 100% (1/1), completed with 1 local object.
   To https://github.com/Nyanyi/Awae
      3d792df..b25c16e  main -> main
   ignasi@debian:~/test/Awae$ 
   ```

